package bgu.dl.features.collections;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Random;

import pddl4j.exp.AtomicFormula;
import pddl4j.exp.Exp;
import pddl4j.exp.action.Action;

import bgu.dl.features.learning.ProblemDetails;

/**
 * @author Shashank Shekhar
 * BGU of the Negev
 * @throws FileNotFoundException 
 */
public class DataSet 
{	
	ProblemDetails details =  null;
	ArrayList<ArrayList<ArrayList>> listOfParentChild = null;
	ArrayList<PossibleGroundedActions> groundedActions = null; 	
	ArrayList<ArrayList<ArrayList>> listParentChildSuccessors = null;
	ArrayList<ArrayList> initialParentChildStates = null;

	public DataSet(ProblemDetails details) {
		this.details = details;
		initialParentChildStates.set(0, null);
		initialParentChildStates.set(1, initialState);
	}

	@SuppressWarnings("rawtypes")
	ArrayList initialState = this.details.getInitialState();
	@SuppressWarnings("rawtypes")
	ArrayList goalState = this.details.getGoalState();

	public void callForDatasetGeneration()
	{
		int randomIndex = randomNumber()-1;
		ArrayList<ArrayList> parentChildStates = initialParentChildStates.get(randomIndex);
		initialParentChildStates.remove(randomIndex);
		initialParentChildStates.addAll(getParentChildSuccessors(parentChildStates)); 
	}

	/**
	 * Random Number Generator
	 * @return an index
	 */
	private int randomNumber() { 
		Random r = new Random();
		int Low = 1;
		int High = initialParentChildStates.size();
		int Result = r.nextInt(High-Low) + Low;
		return Result;
	}

	/**
	 * method generateSuccessorParentChild
	 * @return a list of two states (parent and its child)
	 * A state is also represented in form of a list
	 */
	private ArrayList<ArrayList<ArrayList>> getParentChildSuccessors(ArrayList<ArrayList> parentChildStates) 
	{
		ArrayList<ArrayList<ArrayList>> generateParentChildSuccessors = null;
		ArrayList parentState = parentChildStates.get(0);
		ArrayList childState = parentChildStates.get(1); 

		/**
		 * Keep in mind that, training data points will be computed using each child state.
		 * Call to the Fast Downward by passing the child state, and
		 * the goal state. 
		 */
		
		ArrayList<ArrayList> newParentChildStates = null;
		ArrayList<ArrayList> allPossibleStatetsInForwardDirection = allPossibleStatetsInForwardDirection(childState);

		for (int i = 0; i < allPossibleStatetsInForwardDirection.size(); i++) {
			if(! isSuccessorItsParentState(parentState,allPossibleStatetsInForwardDirection.get(i))) {
				newParentChildStates.set(0, childState);
				newParentChildStates.set(1, allPossibleStatetsInForwardDirection.get(i));
			}
			generateParentChildSuccessors.add(newParentChildStates);			
		}
		return generateParentChildSuccessors;
	}
	
	// Calling to feed one entry in the datatset
	public ArrayList<Integer> generateDataset(ArrayList initialState, ArrayList<AtomicFormula> listOfPossiblePropositions) 
	{
		ArrayList<Integer> listOfInt = new ArrayList<>(listOfPossiblePropositions.size());
		for (int i = 0; i < listOfPossiblePropositions.size(); i++) {
			AtomicFormula af = listOfPossiblePropositions.get(i);
			int val = 0; 
			for (int j = 0; j < initialState.size(); j++) {
				AtomicFormula fromInit = (AtomicFormula)initialState.get(j);
				if (fromInit.getClass().equals(AtomicFormula.class)) {
					if (fromInit.toString().equals(af.toString()))
				} else {

				}
			}
		}
		
		return listOfInt;
	}

	private ArrayList<ArrayList> allPossibleStatetsInForwardDirection(ArrayList childNode) {
		ArrayList<PossibleGroundedActions> getApplicableActions = getApplicableActions(childNode);
		if(getApplicableActions == null) {
			System.out.println("No actions are appicable on this child node: returning null");
			return null;
		}		
		ArrayList<ArrayList> listOfSuccessorStates = null;
		for (int i = 0; i < getApplicableActions.size(); i++) {
			listOfSuccessorStates.add(applyAction(getApplicableActions.get(i), childNode)); 
		}
		return listOfSuccessorStates;
	}

	/**
	 * Generate all applicable actions
	 * @param childNode
	 * @return applicable actions
	 */
	@SuppressWarnings("unused")
	private ArrayList<PossibleGroundedActions> getApplicableActions(ArrayList<AtomicFormula> childNode) {
		ArrayList<PossibleGroundedActions> applicableActions = new ArrayList<PossibleGroundedActions>();
		@SuppressWarnings("rawtypes")
		Iterator itr = groundedActions.iterator();
		while(itr.hasNext()) {
			PossibleGroundedActions ga = (PossibleGroundedActions) itr.next();
			ArrayList<AtomicFormula> preCond = ga.getPreCond();			
			if(isSubsetOf(preCond,childNode)) {
				applicableActions.add(ga);
			}
		}
		return applicableActions;
	}

	/**
	 * Check whether state g is a subset of current state curr
	 * @param g
	 * @param cur
	 * @return
	 */
	private boolean isSubsetOf(ArrayList<AtomicFormula> g, ArrayList<AtomicFormula> cur) {
		return(cur.containsAll(g));		
	}

	/**
	 * Applies a grounded action on the given state
	 * @param groundedAction
	 * @param childNode
	 * @return A successor state
	 */
	@SuppressWarnings("unused")
	private ArrayList<AtomicFormula> applyAction(PossibleGroundedActions groundedAction, ArrayList<AtomicFormula> childNode) {
		ArrayList<AtomicFormula> successorState = new ArrayList<AtomicFormula>();
		// groundedAction.printGroundedAction();
		successorState.addAll(childNode);
		ArrayList<Exp> removeNeg = new ArrayList<Exp>();

		/** Formula: S_{new} = {S_{curr} - stt^{-}(a)} U {eff^{+}(a)} */
		Iterator<AtomicFormula> itrNew = successorState.iterator();
		while(itrNew.hasNext()) {
			Exp exp = itrNew.next();
			if(groundedAction.getNegEff().contains(exp))
				removeNeg.add(exp);
		}
		/** Set Operations */
		successorState.removeAll(removeNeg);
		successorState.addAll(groundedAction.getPosEff());
		return successorState;
	}

	/**
	 * Check if the successor state is the parent node.
	 * @param newState
	 * @return
	 */
	private boolean isSuccessorItsParentState(ArrayList parentState, ArrayList<AtomicFormula> successorState) {
		if(parentState.containsAll(successorState) && successorState.containsAll(parentState))
			return true;
		return false;
	}
}


