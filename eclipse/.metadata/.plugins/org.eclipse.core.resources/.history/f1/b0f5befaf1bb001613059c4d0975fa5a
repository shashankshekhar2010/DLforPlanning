
package bgu.dl.features.collections;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import org.paukov.combinatorics.Factory;
import org.paukov.combinatorics.Generator;
import org.paukov.combinatorics.ICombinatoricsVector;

import pddl4j.PDDLObject;
import pddl4j.exp.AtomicFormula;
import pddl4j.exp.Exp;
import pddl4j.exp.term.Constant;
import bgu.dl.features.learning.PossibleGroundedLiterals;
import bgu.dl.features.learning.ProblemDetails;

/**
 * @author Shashank Shekhar
 * BGU of the Negev
 * */
public class PropContextDataSet {
	ProblemDetails details;
	PDDLObject pddlObject;
	ArrayList<ArrayList<ArrayList>> listOfParentChild;
	ArrayList<PossibleGroundedActions> groundedActions; 	

	public PropContextDataSet() {
		this.details = null;
		this.pddlObject = null;
		this.listOfParentChild = new ArrayList<ArrayList<ArrayList>>();
		this.groundedActions = new ArrayList<PossibleGroundedActions>();
	}

	public void dataSet(ProblemDetails details, PDDLObject object) {
		this.details = details;
		this.pddlObject = object;
		@SuppressWarnings("rawtypes")
		ArrayList initialState = this.details.getInitialState();
		@SuppressWarnings("rawtypes")
		ArrayList goalState = this.details.getGoalState();
	}

	/**
	 *  Will be called from the main file!
	 * */
	public void callForDatasetGeneration(PlanDetails planDetails) {
		File file, file_words, file_context; 		
		Writer writer, writer_words, writer_context;
		PossibleGroundedLiterals possibleGroundedLiterals = new PossibleGroundedLiterals(pddlObject);		
		ArrayList<AtomicFormula> listOfPossiblePropositions = new ArrayList<>();
		listOfPossiblePropositions = possibleGroundedLiterals.allPossibleLiteralsMayOccur();
		details.generateGroundedActions();

		// Call to prepare the data set preparation
		try {
			// training samples
			file = new File("/home/shashank/Dropbox/Bgu-Files/bgu.dl.heuristic/eclipse/bgu.learning/src/bgu/dl/features/TrainingSet.txt");
			writer = new BufferedWriter(new FileWriter(file));

			// words (for word-2-vec representation)
			file_words = new File("/home/shashank/Dropbox/Bgu-Files/bgu.dl.heuristic/eclipse/bgu.learning/src/bgu/dl/features/UnigramDictionary.txt");
			writer_words = new BufferedWriter(new FileWriter(file_words));

			// words (for word-2-vec representation)
			file_context = new File("/home/shashank/Dropbox/Bgu-Files/bgu.dl.heuristic/eclipse/bgu.learning/src/bgu/dl/features/ContextOfEachUnigramWordInTheDict.txt");
			writer_context = new BufferedWriter(new FileWriter(file_context));

			String header = "";
			for (int i = 0; i < listOfPossiblePropositions.size(); i++) {
				header = header + listOfPossiblePropositions.get(i) + "\t";
				header = header + "(not"+ listOfPossiblePropositions.get(i) + ")" + "\t";
			}			
			header = header + header;
			writer_words.append(header); writer_words.close(); // Will write the whole vocabulary
			header = header + "target\n"; writer.append(header); // including (on a b) and (not(on a b))

			useBootstrapping(planDetails, writer_words, writer_context, listOfPossiblePropositions);

			writer_context.close();
			writer.close();			
		} 
		catch (IOException e) {			
			System.out.println("Error in the main dataset preparation function call..."); 
			e.printStackTrace();

		}		
	}

	void useBootstrapping(PlanDetails planDetails, Writer writer, Writer writer_context, ArrayList<AtomicFormula> listOfPossiblePropositions_1)
	{
		ArrayList<AtomicFormula> listOfPossiblePropositions = new ArrayList<AtomicFormula>();
		for (int i = 0; i < listOfPossiblePropositions_1.size(); i++) {
			AtomicFormula af_1 = listOfPossiblePropositions_1.get(i);
			AtomicFormula af_2 = new AtomicFormula("not" + af_1);
			listOfPossiblePropositions.add(af_1);
			listOfPossiblePropositions.add(af_2);
		}

		/**
		 * Keep in mind that, training data points will be computed using each child state.
		 * Call to the Fast Downward by passing the child state, and the goal state. 
		 * */
		PossibleGroundedLiterals possibleGroundedLiterals = new PossibleGroundedLiterals(pddlObject);
		int target = planDetails.getPlanLength();
		ArrayList<String> plan = planDetails.getGeneratedRealPlan();
		
		// Get the real plan
		int count = 0;
		ArrayList<PossibleGroundedActions> realActions = new ArrayList<PossibleGroundedActions>();
		for (int i = 0; i < plan.size(); i++) {
			String actString = plan.get(i); 
			Iterator itr = groundedActions.iterator();
			while(itr.hasNext()) {
				PossibleGroundedActions ga = (PossibleGroundedActions) itr.next();
				boolean flag = ga.isThatGroundedAction(actString);
				if(flag) {
					realActions.add(ga);
					break;					
				}
			}
		}
		
		ArrayList<AtomicFormula> theRealGoal = this.details.getGoalState();
		ArrayList<AtomicFormula> theRealGoalPrime = this.details.getInitialState();		
		for (int i = 0; i < realActions.size(); i++) {
			theRealGoalPrime = applyAction(realActions.get(i), theRealGoalPrime);
		}

		// Extracts the extra things that are achieved during achieving the real goals.
		ArrayList<AtomicFormula> goalPrimeMinusGoal = new ArrayList<AtomicFormula>();
		for (int i = 0; i < theRealGoalPrime.size(); i++) 
		{
			boolean flag = false;
			for (int j = 0; j < theRealGoal.size(); j++) {
				if(theRealGoalPrime.get(i).equals(theRealGoal.get(j))){
					flag = true; break;
				}				
			}
			if (!flag) {
				goalPrimeMinusGoal.add(theRealGoalPrime.get(i));
			}
		}

	}

	/**
	 * Maintaining context in each state.
	 * */
	void callForTheContextOfTheLiteralsInTheCurrentState(ArrayList<Integer>listOfIntegersCorrespondingToLiterals, Writer writer_context)
	{
		String data = "";			
		for (int r = 0; r < listOfIntegersCorrespondingToLiterals.size(); r++) {
			data = data + listOfIntegersCorrespondingToLiterals.get(r) + "\t";
		}	
		data = data + "\n";
		try {
			writer_context.append(data); 
		} catch (IOException e) {			
			e.printStackTrace();
			System.out.println("While writing the contexts");
		}		
	}

	/**
	 * Function call to the fast-downward (FD) planner | keep in mind that the call gets killed after a certain time (say after 30 minutes). 
	 * @param initialState
	 * @param goalState
	 * @return returns the target value, basically, the plan length found by the FD planner.
	 * */
	private PlanDetails targetByFastDownward(ArrayList initialState, PossibleGroundedLiterals possibleGroundedLiterals) {
		int target = 1000000;
		// ArrayList<Constant> listOfConstants = possibleGroundedLiterals.listOfConstants();		
		// A call to create a problem file with new initial state.
		// generateProblemFile(initialState);

		ArrayList<String> plan = new ArrayList<String>();
		PlanDetails details =  new PlanDetails();		
		// A call to the fast downward through python script.
		try {
			String[] command = {
					"/home/shashank/Documents/Copy-IITM/Research-Edited/Fast-Downward/fast-downward.py",
					"/home/shashank/Dropbox/Bgu-Files/bgu.dl.heuristic/eclipse/bgu.learning/src/bgu/dl/features/learning/domain.pddl",
					"/home/shashank/Dropbox/Bgu-Files/bgu.dl.heuristic/eclipse/bgu.learning/src/bgu/dl/features/learning/problem.pddl",
					"--heuristic",
					"h=ff()",
					"--search",
					"lazy_greedy(h, preferred=h)"
			};

			Process pro = Runtime.getRuntime().exec(command);
			BufferedReader in = new BufferedReader(new InputStreamReader(pro.getInputStream()));
			String line = null;
			String[] planDetails = null;
			boolean firstLine = false;
			boolean secondLine = false;
			int count = 0;
			while ((line = in.readLine()) != null) {
				// Conditions for getting the real plans
				if(firstLine) 
					count++;
				if (line.contains("Actual search")) 
					firstLine = true;
				if (line.contains("Plan length"))  
					secondLine = true;

				if(firstLine && count >= 1 && !secondLine) {					
					String[] currAction = line.split(" ");
					String str = "(";
					for (int i = 0; i < currAction.length; i++) {
						if (i < currAction.length-1) { 
							if(i < currAction.length-2) 
								str = str + currAction[i] + " ";
							else
								str = str + currAction[i];
						}
					}
					str = str + ")";		
					plan.add(str.toString());
				}
				// Conditions for getting the real targets predicted by FD.
				if (line.contains("Plan length")) {
					planDetails = line.split(" ");
				}
			}	
			target = Integer.parseInt(planDetails[2]);
			details.setPlanLength(target);
			details.setGeneratedRealPlan(plan);
			// The real plan extraction is ridiculously done, really need an update on that!
		} catch (Exception e) {
			System.err.println("Error in writing the planner output in file !!");
		}
		return details; 
	}

	/**
	 * Will write a new initial state 
	 * @param initialState
	 * @param goalState
	 * @param listOfConstants */
	private void generateProblemFile(ArrayList initialState) 
	{ 
		List<String> lines = new ArrayList<String>();
		String line = null;
		try {
			File f1 = new File("/home/shashank/Dropbox/Bgu-Files/bgu.dl.heuristic/eclipse/bgu.learning/src/bgu/dl/features/learning/problem.pddl");
			FileReader fr = new FileReader(f1);
			BufferedReader br = new BufferedReader(fr);
			String str ="(:init ";
			for (int i = 0; i < initialState.size(); i++) {
				str = str + initialState.get(i).toString();
			}
			str = str + ")";
			while ((line = br.readLine()) != null) {
				if (line.contains(":init") || line.contains(":INIT") )
				{
					line = line.replace(line, str);
				}
				lines.add(line);
			}
			fr.close();
			br.close();

			FileWriter fw = new FileWriter(f1);
			BufferedWriter out = new BufferedWriter(fw);
			for(String s : lines)
			{
				out.write(s);
				out.write("\n");
			}
			out.flush();
			out.close();
		} catch (Exception ex) {
			ex.printStackTrace();
		}
	}

	// Calling to feed (0 or 1) corresponding to each entry in the list of proposition
	private ArrayList<Integer> generateDataset(ArrayList givenState, ArrayList<AtomicFormula> listOfPossiblePropositions) 
	{		
		/*ArrayList<AtomicFormula> listOfPossiblePropositions = new ArrayList<AtomicFormula>();
			for (int i = 0; i < listOfPossiblePropositions_1.size(); i++) 
			{
				AtomicFormula af_1 = listOfPossiblePropositions_1.get(i);
				AtomicFormula af_2 = new AtomicFormula("not" + af_1);
				listOfPossiblePropositions.add(af_1);
				listOfPossiblePropositions.add(af_2);
			}*/

		// No closed world assumptions - basically.
		ArrayList<Integer> listOfInt = new ArrayList<Integer>();
		for (int i = 0; i < listOfPossiblePropositions.size(); i++) {
			listOfInt.add(0);
		}

		for (int i = 0; i < listOfPossiblePropositions.size(); i++) 
		{
			AtomicFormula af = listOfPossiblePropositions.get(i);
			if(af.getPredicate().contains("not"))
			{
				if(listOfInt.get(i-1) == 0)
				{
					listOfInt.set(i, 1);	
				}
				continue;
			}
			// Considering the closed world assumptions, we give a default value 0 to each literal.
			int val = 0;
			for(int j = 0; j < givenState.size(); j++) {
				AtomicFormula fromInit = (AtomicFormula) givenState.get(j);
				if (fromInit.toString().equals(af.toString())) {
					val = 1;
					break;
				} 
			}	

			try {				
				listOfInt.set(i, val);				
			} 
			catch (Exception e) {
				System.out.println("error - updating values : in the call of generateDataset()");	
			}
		}
		// this list is correct!		
		return listOfInt;
	}

	/**
	 * Check whether state g is a subset of current state currentState
	 * @param goalState
	 * @param currentState
	 * @return status on whether g is subset is current. */
	private boolean isSubsetOf(ArrayList<AtomicFormula> goalState, ArrayList<AtomicFormula> currentState) {
		return(currentState.containsAll(goalState));		
	}

	/**
	 * Applies a grounded action on the given state
	 * @param groundedAction
	 * @param childNode
	 * @return a successor state */
	private ArrayList<AtomicFormula> applyAction(PossibleGroundedActions groundedAction, ArrayList<AtomicFormula> childNode) {
		ArrayList<AtomicFormula> successorState = new ArrayList<AtomicFormula>();
		successorState.addAll(childNode);
		ArrayList<Exp> removeNeg = new ArrayList<Exp>();
		// groundedAction.printGroundedAction();

		/** Formula: S_{new} = {S_{current} - effect^{-}(a)} U {effect^{+}(a)} */
		Iterator<AtomicFormula> itrNew = successorState.iterator();
		while(itrNew.hasNext()) {
			Exp exp = itrNew.next();
			if(groundedAction.getNegEff().contains(exp))
				removeNeg.add(exp);
		}

		/** Set Operations */
		successorState.removeAll(removeNeg);
		successorState.addAll(groundedAction.getPosEff());		
		return successorState;
	}

	/**
	 * Returns all possible combinations of extra goal predicates achieved during the plan execution.
	 * @param apartFromTheGoals
	 * @return generateAllPossibleCombiOfExtraGoalAchieved **/
	public ArrayList<ArrayList<AtomicFormula>> generateAllPossibleCombiOfExtraGoalAchieved(ArrayList<AtomicFormula> apartFromTheGoals) {
		ArrayList<ArrayList<AtomicFormula>> generateAllPossibleCombiOfExtraGoalAchieved = new ArrayList<ArrayList<AtomicFormula>>();
		ArrayList<AtomicFormula> eachCombiOfExtraGoals = new ArrayList<AtomicFormula>();
		for (int i = 0; i < apartFromTheGoals.size(); i++) {
			int count = i+1;
			ICombinatoricsVector<AtomicFormula> combinatoricsVector = Factory.createVector(apartFromTheGoals);
			Generator<AtomicFormula> generator = Factory.createSimpleCombinationGenerator(combinatoricsVector, count);

			/** Read all possible combinations */
			for (ICombinatoricsVector<AtomicFormula> combination : generator) 
			{
				java.util.List<AtomicFormula> l = combination.getVector();
				ICombinatoricsVector<AtomicFormula> temp = Factory.createVector(l);
				Generator<AtomicFormula> genPerm = Factory.createPermutationGenerator(temp);
				for (ICombinatoricsVector<AtomicFormula> perm : genPerm) {
					java.util.List<AtomicFormula> p = perm.getVector();
					eachCombiOfExtraGoals = new ArrayList<AtomicFormula>();
					Iterator<AtomicFormula> itr = p.iterator();
					while(itr.hasNext()) {
						eachCombiOfExtraGoals.add(itr.next());				
					}
					generateAllPossibleCombiOfExtraGoalAchieved.add(eachCombiOfExtraGoals);
				}
			}
		}
		return generateAllPossibleCombiOfExtraGoalAchieved;
	}
}
